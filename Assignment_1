/* 
Carlos and Tylers first assignment

Using numbers to represent cards 
* 3 digits
  * first digit represents suit
    * 1xx represents hearts
    * 2xx represents diamonds
    * 3xx represents clubs
    * 4xx represents spades
  * the 2nd and 3rd digits represent face values
    * x01 represents aces
    * x02 represents twos
    * x03 represents threes
    * ...
    * x10 represents tens
    * x11 represents jacks
    * x12 represents queens
    * x13 represents kings
Check for pair using modulus
  * if (card1 % 100 == card2 %100) // will return true for pair
  
Creating, shuffling, dealing, and discarding with the deck
  * queue does not allow us to traverse the list to print the contents between hands
  * deque (pronounced deck) should allow traversal
  * std::shuffle should work with deque to randomize the deck
  
**** to run on the school server ***
upload this file as a *.cpp
navigate to the folder containing the file
enter the following to compile:
  g++ -std=c++11 filename.cpp   // need to add -pthread once we implement them
then enter the following to run:
  ./a.out
  
  We can write a make file to simplify this for submission...
 

*/

#include <iostream>     // std::cout
#include <algorithm>    // std::shuffle
#include <deque>        // std::deque
#include <random>       // std::default_random_engine
#include <chrono>       // std::chrono::system_clock

using namespace std;

// *** Prototypes ***
deque<int> populateDeck(deque<int> d);
deque<int> shuffleDeck(deque<int> d);
void printDeck(deque<int> d);
void initialDeal(deque<int> &d, deque<int> &p1, deque<int> &p2, deque<int> &p3);
bool drawCard(deque<int> &d, deque<int> &p);
void discard(deque<int> &d, deque<int> &p);

int main(){
   
deque<int> deck;
  deque<int> p1;
  deque<int> p2;
  deque<int> p3;
  deque<int> order;
  
      while(r <= 3){
        round();
        r++;            //need to create a winner function to end round
        bool winner = false;
    }
  
  // allows us to pop/push to increment player order each round
  for (int i=0; i<3; i++) order[i]=(i+1);

  printDeck(deck);
  deck = populateDeck(deck);
  printDeck(deck);
  deck = shuffleDeck(deck);
  printDeck(deck);
  
  initialDeal(deck, p1, p2, p3);
  printDeck(deck);
  printDeck(p1);
  printDeck(p2);
  printDeck(p3);
  
  
  winner = drawCard(deck, p1);
  if(winner){
     cout<< "player 1 won!" << endl;
     printDeck(p1);
  }
  else {
       printDeck(p1);
       discard(deck, p1);
  }
  winner = drawCard(deck, p2);
  if(winner){
     cout<< "player 2 won!" << endl;
     printDeck(p2);
  }
  else{
       printDeck(p2);
       discard(deck, p2);
  }
  winner = drawCard(deck, p3);
  if(winner){
     cout<< "player 3 won!" << endl;
     printDeck(p3);
  }
  else{
       printDeck(p3);
       discard(deck, p3);
  }
  
  printDeck(p1);
  printDeck(p2);
  printDeck(p3);
  printDeck(deck);
  
}

// *** Functions ***
// populate the deck
 deque<int> populateDeck(deque<int> d){
  for(int i = 1; i <= 4; i++){
    for(int ii = 1; ii <= 13; ii++){
      int addCard = (i*100 + ii);
      d.push_back(addCard);
    }
  }
  return d;
 }

// shuffle the deck
 deque<int> shuffleDeck(deque<int> d){
  unsigned seed = chrono::system_clock::now().time_since_epoch().count();
  shuffle(d.begin(), d.end(), default_random_engine(seed));
  return d;
}

// print the deck contents
void printDeck(deque<int> d){
   if(d.size() == 0){
      cout << "\nThe deck is empty" << endl;
   }
   else{
      cout << "\nThe deck contains:" << endl;
      for(int i = 0; i < d.size(); i++){
         cout << d.at(i)  << " " ;
      }
   }
  cout << "\n * * * * * * * * * * * * * * * * * * " << endl;
  return;
}

//  deal initial cards
void initialDeal(deque<int> &d, deque<int> &p1, deque<int> &p2, deque<int> &p3){
   for(int i = 0; i < 3; i++){
      int cardToDeal = d.front();
      d.pop_front();
      if(i==0) p1.push_back(cardToDeal);
      else if (i==1) p2.push_back(cardToDeal);
      else p3.push_back(cardToDeal);
   }
}

//  individual player draws a card
bool drawCard(deque<int> &d, deque<int> &p){
   bool won = false;
   int cardToDraw = d.front();
   d.pop_front();
   p.push_back(cardToDraw);
   if((p.front()%100) == (p.back()%100)){
      won = true;
   }
   else won = false;
   return won;
   
}

//  individual player discards a card
void discard(deque<int> &d, deque<int> &p){
   unsigned seed = chrono::system_clock::now().time_since_epoch().count();
   srand (seed);
   int toDiscard = rand() % 100 + 1;
   cout << "discard card # :" << toDiscard << endl;
   if(toDiscard%2 == 0){
      int cardToDiscard = p.front();
      p.pop_front();
      d.push_back(cardToDiscard);
   }
   else {
      int cardToDiscard = p.back();
      p.pop_back();
      d.push_back(cardToDiscard);
   }
}


/*rounds                    //will need to create dealer and player thread functions
void round(){               //will need to look more into pthreads for this part
    int threadDealer = pthread_create();
    
    int threadPlayer;
    for(r = 1; r <= 3; r++ )
    {
        threadPlayer = pthread_create();
    }
    
    pthread_join();         //will join player and dealer thread
    {
        
    }
    
}
*/
